#!/usr/bin/env ruby

require 'open3'

pid = "#{ENV["HOME"]}/.local/uscreencast.pid"
if File.exist?(pid)
  pid_value = File.read(pid).to_i
  File.unlink(pid)
  Process.kill('INT', pid_value)
  `notify-send "recording stopped"`
  exit(0)
end

`notify-send "recording started"`

date = `date +%s`.strip()
file = "screen_#{date}.avi"
gif = "screen_#{date}.gif"

if ARGV.include?('--active-window')
  active_window_id =
    `xprop -root | grep "_NET_ACTIVE_WINDOW(WINDOW)"`
      .strip()[40..-1]
  active_window_info = `xwininfo -id #{active_window_id}`
else
  # active_window_id = 'root'
  active_window_info = `xwininfo -root`
end

x = active_window_info.match(/Absolute upper-left X:\s*(\d+)/)[1]
y = active_window_info.match(/Absolute upper-left Y:\s*(\d+)/)[1]
width = active_window_info.match(/Width:\s*(\d+)/)[1]
height = active_window_info.match(/Height:\s*(\d+)/)[1]

# -f alsa -i hw:1 \

command = "
  ffmpeg \
    -f x11grab \
    -framerate 25 \
    -video_size #{width}x#{height} \
    -i :0+#{x},#{y} \
    -codec:v libx264 \
    -b:v 20000k \
    -vf crop=\"iw-mod(iw\\,2):ih-mod(ih\\,2)\" \
    -y \"#{file}\"
"

Open3.popen3(command) { |stdin, stdout, stderr, thread|
  File.write(pid, thread.pid.to_s)
  Process.wait(thread.pid) rescue nil
}

if ARGV.include?('--gif')
  `notify-send "starting conversion"`

  system("
    temp_dir=$(mktemp -d);
    ffmpeg -i \"#{file}\" -r 10 $temp_dir/out%06d.png;
    ls -1 $temp_dir/out*.png | xargs -P8 -II -n1 convert -verbose I I.gif;
    gifsicle --delay=8 --optimize --loop $temp_dir/*.gif > \"#{gif}\";
    rm -r $temp_dir;
  ")
  File.unlink(file)
  file = gif
end

if ARGV.include?('--publish')
  `notify-send "starting uploading"`

  link = `yandex-disk publish #{file}`
  if ARGV.include?('--publish-copy-link')
    `echo -n "#{link.strip}" | xsel -ib`
  end
end

`notify-send "screencast made"`

File.unlink()
