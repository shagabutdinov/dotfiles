autoload -U add-zsh-hook
source ~/bin/_zsh-hijack

export BROWSER=chromium
export APPLICATION_ENV=development
export LC_ALL="en_US.UTF-8"

export PROMPT="%{$bg[blue]%}%{$fg[white]%}%2~ å†¬%{$reset_color%} "
export GOPATH=~/src/go

HISTSIZE=999999999
SAVEHIST=999999999

APPEND_HISTORY=yes
INC_APPEND_HISTORY=yes
SHARE_HISTORY=yes

HIST_IGNORE_DUPS=no
HIST_IGNORE_ALL_DUPS=no
HIST_EXPIRE_DUPS_FIRST=no
HIST_SAVE_NO_DUPS=no
HIST_FIND_NO_DUPS=no

export TERM='rxvt-unicode'
export COLORTERM='rxvt-unicode-256color'

autoload -U select-word-style
select-word-style bash

bindkey "\e\e[D" backward-word
bindkey "\e\e[C" forward-word

bindkey "^[OA" hijack:history-substring-search-up
bindkey "^[[A" hijack:history-substring-search-up

autoload -U promptinit
promptinit

zle -N prepend-sudo prepend_sudo
function prepend_sudo() {
        if [ "$BUFFER" ]; then
                BUFFER="sudo "$BUFFER
        else
                BUFFER="sudo "$(fc -ln -1)
        fi
        CURSOR=$(($CURSOR+5))
}

function o() {
  nohup xdg-open "$@" > /dev/null 2> /dev/null &
  disown
}

bindkey "^T" prepend-sudo
alias -g G="| grep"

alias yaourt='yaourt --noconfirm --m-arg --skipchecksums --m-arg --skippgpcheck'
alias mv=/bin/mv
alias pwgen='pwgen 12'
alias nc='sudo netctl'
alias ag='alias | grep -A 2 -B 2'
alias cds='cd ~/src/'

alias s='subl3 -a'
alias ss='subl3 -n'
alias h='ssh'
alias b='bundle exec'
alias bi='bundle install --path vendor/bundle --jobs 32'
alias X='| xsel -ib'
alias w='inotifyrun -r -e MODIFY'
alias l='ls --color -hl --group-directories-first'
alias ls='ls --color -h --group-directories-first'

alias pm='sudo pacman'
alias pms='sudo pacman -S'
alias pmr='sudo pacman -R'
alias pmro='sudo pacman -Rns $(pacman -Qtdq)'
alias pmq='pacman -Ql'

alias sc='sudo systemctl'
alias sca='sudo systemctl start'
alias sce='sudo systemctl restart'
alias sco='sudo systemctl stop'
alias scs='sudo systemctl status'

alias dfp='balmora dotfiles-submit'
alias dfu='balmora dotfiles-update'

export GREP_OPTIONS=''
export NODE_PATH="~/.node:/usr/lib/node_modules"
export WINEARCH='win32'

alias grep='grep --exclude-dir=.cvs --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --color=auto'
alias tree='tree --dirsfirst'
alias ps='ps -xau'
alias cal='cal -m $(date +%Y)'
alias uwhatsapp='chromium --app=https://web.whatsapp.com'

alias wr='nmcli -p dev wifi rescan'
alias wd='nmcli -p dev wifi list'
alias wc='nmcli -p dev wifi connect'
alias wl='nmcli -p con show'
alias ws='nmcli -p con show --active'
alias wu='nmcli -p con up id'

alias d='docker'
alias dx='docker exec -i -t'
alias di='docker inspect'
alias dp='docker ps --format "table{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}"'
alias dr='docker run --rm -i -t'
alias drm='docker rm  --force'
alias drma='docker rm --force $(docker ps -q -a)'
alias ds='docker stop'
alias dsa='docker stop $(docker ps -q)'
alias dt='docker start'
alias de='docker restart'
alias dl='docker logs --tail 200'
alias dlf='docker logs --follow'
alias da='docker attach --no-stdin'

:kubectl() {
    local arg
    local context
    local args=()
    local entity

    for arg in "$@"; do
        if [[ "$arg" =~ @.* ]]; then
            context=$(
                kubectl config get-contexts --no-headers -o name \
                    | grep -P "^${arg:1}"
            )
        else
            args+=("$arg")
        fi
    done

    set -- "${args[@]}"

    args=()
    targets=()

    if [[ ! "$context" ]]; then
        context=$(kubectl config current-context)
    fi

    for arg in "$@"; do
        if [[ "$arg" =~ %.* ]]; then
            entity=${arg%/*}

            if [[ "$entity" == "$arg" ]]; then
                entity=pod
            fi

            args+=($(
                kubectl --context=$context get "$entity" --no-headers \
                        -o name \
                    | cut -f2- -d/ \
                    | grep -P "^${${arg:1}#*/}" \
                    | head -n 1
            ))
        else
            args+=("$arg")
        fi
    done


    kubectl --context=$context ${(q)args[@]}
}

alias k=':kubectl'
alias ka='k apply'
alias kaf='k apply -f'
alias kl='k logs'
alias klf='k logs -f'
alias kd='k describe'
alias kdp='k describe pods'
alias kds='k describe services'
alias kdd='k describe deployment'
alias kc='k create'
alias kcf='k create -f'
alias kr='k delete'
alias krf='k delete -f'
alias krp='k delete pod'
alias krs='k delete service'
alias krd='k delete deployment'
alias kg='k get'
alias kgp='k get pods --show-all'
alias kga='k get pods --show-all --all-namespaces -o wide'
alias kgs='k get services'
alias kgd='k get deployments'
alias kx='() { k exec -it $1 -- "${@:2}"}'
alias kxb='() { k exec -it $1 bash }'
alias kxc='() { k exec -it $1 rails c }'
alias kxx='k run -i --tty busybox --image=busybox --restart=Never -- sh'
alias kei='k exec'
alias kgn='kubectl config current-context'
alias ksc='kubectl config use-context '

alias ksn='() {
  project=$(kubectl config current-context | grep -Po "(?<=@)\w+")
  namespace=$(kubectl config get-contexts | grep -Po "$1\w*(?=@$project)" | head -n 1)
  kubectl config use-context $namespace@$project
}'

alias ksp='() {
  project=$(kubectl config get-contexts | grep -Po "(?<=@)$1\w*(?=\s)" | head -n 1)
  namespace=$(kubectl config current-context | grep -Po "\w+(?=@)")
  if [ ! "$namespace" ]; then
    namespace=$project
  fi

  kubectl config use-context $namespace@$project
}'


alias c='docker-compose -f'

alias kxd='
  open-kubernetes-database-console \
    $(production-namespace postgres) \
    $(production-pod postgres)
'

alias kzc='
  k \
    --namespace staging \
    exec \
      -it \
      $(staging-pod "(app|backend)") \
      -- \
      rails c \
'

alias kzd='
  open-kubernetes-database-console \
    staging \
    $(staging-pod postgres)
'

function open-kubernetes-database-console() {
  export DB=$(
    kubectl exec \
      --namespace $1 \
      $2 \
      -- \
      psql -P pager -Upostgres -c '\l' | \
      grep -E '^ ' | \
      grep -Ev '^ (postgres|template|ubuntu| )' | \
      grep -Eo '^ \w+' |
      grep -Eo '\w+'
  )

  kubectl \
    --namespace $1 \
    exec \
    -it \
    $2 \
    -- \
    psql -P pager -Uuser \
    $DB
}

function staging-pod() {
  kubectl get pods --all-namespaces -o wide | \
    grep staging | \
    grep -Eo " $1-[0-9]+-[a-Z0-9]+" | \
    head -n 1
}

function production-pod() {
  kubectl get pods --all-namespaces -o wide | \
    grep -v staging | \
    grep -Eo " $1-[0-9]+-[a-Z0-9]+" | \
    head -n 1
}

function production-namespace() {
  kubectl get pods --all-namespaces -o wide | \
    grep -v staging | \
    grep -E " $1-[0-9]+-[a-Z0-9]+" | \
    grep -Eo "^\w+" | \
    head -n 1
}

alias cm='\
  docker-compose -f config/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml \
'

alias cu='\
  docker-compose -f config/**/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml up \
'

alias cs='\
  docker-compose -f config/**/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml stop \
'

alias cr='\
  docker-compose -f config/**/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml stop;
  docker-compose -f config/**/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml up \
'

alias crm='\
  docker-compose -f config/**/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml stop;
  docker-compose -f config/**/$(ls --color=none config/ | \
    grep --color=none \\.local)/main.yml rm
'

function restart-project() {
  PROJECT_PATH=$(project-path)

  PROJECT_ENV=$(
    ls --color=none $PROJECT_PATH/config/ |
      grep --color=none \\.local
  )

  docker-compose -f $PROJECT_PATH/config/$PROJECT_ENV/main.yml stop
  docker-compose -f $PROJECT_PATH/config/$PROJECT_ENV/main.yml up
}


alias co='sudo chown -R leo: '
alias cc='sudo chown -R leo: .'

alias gs='git show --color'
alias gsp='git commit -v -a && git push'
alias gsa='git commit -v -a --amend && git push --force'
alias gsn='git commit -v -a --amend --no-verify && git push --force'
alias gcn='git commit --no-verify'
alias gpf='git push --force'
alias ge='git rebase'
alias gei='git rebase --interactive'
alias gec='git rebase --continue'
alias gea='git rebase --abort'
alias gpu='git push -u origin $(current_branch)'
alias gdd='git diff --color | diff-so-fancy | less'
alias gdc='git diff --cached'
alias gh='git stash'
alias ghp='git stash pop'
alias gfp='git fetch --prune'
alias gcb='git checkout origin/dev'
alias gcm='git checkout origin/master'
alias gcs='git checkout origin/staging'
alias gt='git reset'
alias gth='git reset --hard'
alias glr='git pull --rebase'

alias gg='() { git commit -m "$1" }'
alias gg!='() { git commit --amend -m "$1" }'
alias ggx='() { git commit --amend -m "$1" }'

alias gk='() { git add . ; git commit -m "$1" }'
alias gk!='() { git add . ; git commit -m "$1" --amend }'
alias gkx='() { git add . ; git commit -m "$1" --amend }'

alias gx='() {
  git add .
  git commit -m "$1"
  git push -u origin $(current_branch)
}'

alias gxx='() {
  git add .
  git commit -m "$(git log -1 --pretty=%s)" --amend
  git push -u origin $(current_branch) --force
}'

function rebase-current-branch-on-master() {
  git fetch
  git rebase origin/master
}

alias geo=rebase-current-branch-on-master

alias json='python -m "json.tool"'

function application-container() {
  echo $(docker-container "(backend|app|rails)\." -v admin)
}

function docker-container() {
  echo $(
    docker ps --format "table{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}" |
    grep -E $1 |
    grep $2 $3 |
    sort -k 2 |
    head -n 1 |
    awk "{ print \$1 }"
  )
}

alias dbe='docker exec -i -t $(application-container)'
alias dbea='docker exec -i -t $(docker-container "(backend|app|rails)\." admin)'
alias dte='docker exec -i -t $(docker-container "test.(backend|app|rails)" backend)'
alias dfe='docker exec -i -t $(docker-container frontend -v admin)'
alias dfea='docker exec -i -t $(docker-container frontend admin)'

alias isd='issue -S --from origin/dev --id '
alias ism='issue -S --from origin/master --id '

alias x='docker exec -i -t $(application-container)'
alias xx='docker exec -i -t $(application-container)'
alias xb='docker exec -i -t $(application-container) bash'
alias xc='docker exec -i -t $(application-container) rails console'
alias xr='docker exec -i -t $(application-container) rails runner'
alias xdm='docker exec -i -t $(application-container) rake db:migrate'
alias xdr='docker exec -i -t $(application-container) rake db:rollback'
alias xdd='docker exec -i -t $(application-container) rake db:migrate:redo'
alias xdt='docker exec -i -t $(application-container) rake db:migrate:status'
alias xds='docker exec -i -t $(application-container) rake db:seed'

alias xdi='
  docker exec -i -t $(application-container) \
    rake db:create db:structure:load db:seed
'

alias xbi='
  docker exec -i -t $(application-container) \
    bundle install --jobs 8 --path vendor/bundle --full-index \
'

function open-project-database-console() {
  CONTAINER=$(docker-container postgres -v admin)
  if [ -n "$CONTAINER" ]; then
    docker exec -i -t $CONTAINER psql -P pager -U postgres database
  fi

  CONTAINER=$(docker-container mysql -v admin)
  echo $CONTAINER
  if [ -n "$CONTAINER" ]; then
    docker exec -i -t $CONTAINER mysql -u user -ppassword database
  fi

  echo "NO DATABASE CONTAINER FOUND"
}

alias xd='open-project-database-console'

alias xy='
  bundle exec cap staging deploy deploy:migrate api:restart \
    sidekiq:stop sidekiq:start
'

alias xyp='
  bundle exec cap production deploy deploy:migrate api:restart \
    sidekiq:stop sidekiq:start
'

alias z=' \
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
'

alias zx=' \
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rspec \
'

alias zb=' \
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) bash
'

alias zs=' \
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    spring \
'

alias zc='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rails console \
'

alias zr='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rails runner \
'

alias zdm='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rake db:migrate \
'

alias zdr='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rake db:rollback \
'

alias zdd='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rake db:migrate:redo \
'

alias zdt='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rake db:migrate:status \
'

alias zdi='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rake db:create db:structure:load \
'

alias zds='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    rake db:seed \
'

alias zbi='
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) \
    bundle install --jobs 8 --path vendor/bundle --full-index \
'

alias zd='docker exec -i -t $(docker-container postgres -v admin) \
  psql -P pager -U postgres test \
'

function backend-path() {
  RESULT=$(
    docker inspect $(application-container) |
      grep -o '/.*:/app:rw' | sed -E "s/:.*//"
  )

  echo $RESULT
}

function project-path() {
  echo $(backend-path)/..
}

function xgm {
  MIGRATION=$(
    docker exec -i -t $(application-container) rails generate migration $@ |
      grep -o 'db/.*.rb' |
      head -n 1
  )

  docker exec -i -t $(application-container) chown 1000:1000 $MIGRATION
  subl3 $(backend-path)/$MIGRATION
}

alias xp='cd $(project-path)/app'

umask 002

eval "$(ssh-agent -s)" > /dev/null 2>&1
ssh-add > /dev/null 2>&1

function deploy-filmservice-to-staging {
  docker exec -i -t $(docker-container "test.(backend|app|rails)" -v admin) rspec
  if [ $? -ne 0 ]; then
    echo "\033[0;31mBUILD FAILED\033[0m"
    return 1
  fi

  git push
  if [ $? -ne 0 ]; then
    echo "\033[0;31mPUSH FAILED\033[0m"
    return 1
  fi

  bundle exec cap staging deploy deploy:migrate sidekiq:restart
  if [ $? -ne 0 ]; then
    echo "\033[0;31mDEPLOY FAILED\033[0m"
    return 1
  fi

  return 0
}

function kubernetes-pod {
  kubectl --context $1 get pods | grep -Po $2 | head -n 1
}

function download-filmservice-staging-data {
  cd $(project-path)

  docker stop $(docker-container "(backend)\." -v admin)
  docker stop $(docker-container "(app)\." -v admin)

  docker exec -i $(docker-container postgres -v admin) psql -U postgres \
    -c 'DROP DATABASE IF EXISTS "database"'

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  kubectl exec --context staging@filmservice -i \
    $(kubernetes-pod staging@filmservice 'postgres-[\w\-]+') -- \
    sh -c "pg_dumpall -Upostgres | gzip" |
      gunzip |
      docker exec -i $(docker-container postgres -v admin) psql -U postgres

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH SUPERUSER;"

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH PASSWORD 'password';"

  docker-compose -f config/filmservice.local/main.yml stop
  echo y | docker-compose -f config/filmservice.local/main.yml rm
  docker-compose -f config/filmservice.local/main.yml up -d

  return 0
}

function download-filmservice-production-data {
  cd $(project-path)

  docker stop $(docker-container "(backend)\." -v admin)
  docker stop $(docker-container "(app)\." -v admin)

  docker exec -i $(docker-container postgres -v admin) psql -U postgres \
    -c 'DROP DATABASE IF EXISTS "database"'

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  kubectl exec --context filmservice@filmservice -i \
    $(kubernetes-pod filmservice@filmservice 'postgres-[\w\-]+') -- \
    sh -c "pg_dumpall -Upostgres | gzip" |
      gunzip |
      docker exec -i $(docker-container postgres -v admin) psql -U postgres

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  docker exec -i $(docker-container postgres -v admin) psql -U postgres \
    -c 'ALTER DATABASE "diagonal_production" RENAME TO "database"'

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH SUPERUSER;"

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH PASSWORD 'password';"

  docker-compose -f config/filmservice.local/main.yml stop
  echo y | docker-compose -f config/filmservice.local/main.yml rm
  docker-compose -f config/filmservice.local/main.yml up -d

  return 0
}

function download-filmservice-staging-data-to-production {
  kubectl --context staging@filmservice delete deployment \
    app backend area51 sidekiq clockwork

  kubectl exec -i \
    --context staging@filmservice \
    $(kubernetes-pod staging@filmservice 'postgres-[\w\-]+') \
      -- sh -c 'psql -Upostgres -c DROP DATABASE IF EXISTS "database"'

  kubectl exec \
    --context filmservice@filmservice \
    $(kubernetes-pod filmservice@filmservice 'postgres-[\w\-]+') \
    -- sh -c "pg_dumpall -Upostgres | gzip" | \
  kubectl exec -i \
    --context staging@filmservice \
    $(kubernetes-pod staging@filmservice 'postgres-[\w\-]+') \
      -- sh -c "gunzip | psql -Upostgres "

  kubectl --context staging@filmservice apply -f \
    /home/leo/src/filmservice.net/config/staging.filmservice.net/kubernetes.yml

  kubectl exec \
    --context staging@filmservice \
    $(kubernetes-pod staging@filmservice 'postgres-[\w\-]+') -- \
    psql -Upostgres -c \
      'ALTER DATABASE "diagonal_production" RENAME TO "database";'

  kubectl exec \
    --context staging@filmservice \
    $(kubernetes-pod staging@filmservice 'postgres-[\w\-]+') -- \
    psql -Upostgres -c 'ALTER USER "user" WITH SUPERUSER;'

  kubectl exec \
    --context staging@filmservice \
    $(kubernetes-pod staging@filmservice 'postgres-[\w\-]+') -- \
    psql -Upostgres -c "ALTER USER \"user\" WITH PASSWORD 'password';"
}

function download-altagram-production-data {
  cd $(project-path)

  docker stop $(docker-container "(backend)\." -v admin)
  docker stop $(docker-container "(app)\." -v admin)

  docker exec -i $(docker-container postgres -v admin) psql -U postgres \
    -c 'DROP DATABASE IF EXISTS "database"'

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  kubectl exec --namespace altagram -i \
    $(kubectl --namespace altagram get pods | \
      grep -Eo 'postgres-[0-9]+-[a-Z0-9]+' | head -n 1) -- \
    pg_dumpall -Uuser | \
    docker exec -i $(docker-container postgres -v admin) psql -Upostgres

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH SUPERUSER;"

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH PASSWORD 'password';"

  docker-compose -f config/altagram.local/main.yml stop
  echo y | docker-compose -f config/altagram.local/main.yml rm
  docker-compose -f config/altagram.local/main.yml up -d

  return 0
}

function download-altagram-staging-data {
  cd $(project-path)

  docker stop $(docker-container "(backend)\." -v admin)
  docker stop $(docker-container "(app)\." -v admin)

  docker exec -i $(docker-container postgres -v admin) psql -U postgres \
    -c 'DROP DATABASE IF EXISTS "database"'

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  kubectl exec --namespace staging -i \
    $(kubectl --namespace staging get pods | \
      grep -Eo 'postgres-[0-9]+-[a-Z0-9]+' | head -n 1) -- \
    pg_dumpall -Uuser | \
    docker exec -i $(docker-container postgres -v admin) psql -Upostgres

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH SUPERUSER;"

  docker exec -i $(docker-container postgres -v admin) psql -Upostgres -c \
    "ALTER USER \"user\" WITH PASSWORD 'password';"

  if [ $? -ne 0 ]; then
    echo "\033[0;31mDOWNLOAD FAILED\033[0m"
    return 1
  fi

  docker-compose -f config/altagram.local/main.yml stop
  echo y | docker-compose -f config/altagram.local/main.yml rm
  docker-compose -f config/altagram.local/main.yml up -d

  return 0
}

alias clr=restart-project

function generate-rails-object() {
  RESULT=$(
    docker exec -i -t $(application-container) \
      rails generate $@ | tee /dev/tty \
  )

  if [ $? -ne 0 ]; then
    echo "\033[0;31mGENERATE FAILED\033[0m"
    return 1
  fi

  FILES=$(
    echo $RESULT |
      grep -E '(create|identical|skip)' | # filter for created files
      sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" | # remove colors
      sed -E "s/*(create|identical|skip)[\t ]*//" # remove garbage
  )

  PROJECT_PATH=$(project-path)
  for FILE in $(echo $FILES); do
    FILE=$(echo $FILE | sed -E 's/\r//')
    FILE_PATH='() { $(backend-path)/$FILE }'
    if ! test -e $FILE_PATH; then
      FILE_PATH="$(backend-path)/app/$FILE"
    fi

    sudo chown leo: $FILE_PATH
    subl3 $FILE_PATH
  done
}

alias xg=generate-rails-object

function create-feature-branch() {
  git fetch
  if [ $? -ne 0 ]; then
    echo "\033[0;31mFETCH FAILED\033[0m"
    return 1
  fi

  git checkout origin/master
  if [ $? -ne 0 ]; then
    echo "\033[0;31mCHECKOUT FAILED\033[0m"
    return 1
  fi

  git checkout -b "$1"
  if [ $? -ne 0 ]; then
    echo "\033[0;31mNEW BRANCH CHECKOUT FAILED\033[0m"
    return 1
  fi
}

alias gn=create-feature-branch

function create-pull-request() {
  repo=$(
    git remote -v |
      grep push |
      sed -r "s/.*@(.*):(.*)\.git\s.*/http:\/\/\1\/\2/g"
  )

  chromium "$repo/compare/$(current_branch)?expand=1"
}

alias gq=create-pull-request

function merge-current-branch-to-staging() {
  branch=$(current_branch)

  if $(echo $branch | grep -e '-STAGING-TMP$'); then
    echo "\033[0;31mAlready on staging branch\033[0m"
  fi

  git fetch
  if [ $? -ne 0 ]; then
    echo "\033[0;31mFetch failed\033[0m"
    return 1
  fi

  git checkout origin/staging
  if [ $? -ne 0 ]; then
    echo "\033[0;31mFailed to checkout\033[0m"
    return 1
  fi

  git checkout -b "$branch-STAGING-TMP"
  if [ $? -ne 0 ]; then
    echo "\033[0;31mFailed to checkout new branch\033[0m"
    return 1
  fi

  git merge --no-edit "$branch"
  if [ $? -ne 0 ]; then
    echo "\033[0;31mAutomatica merge failed\033[0m"
    return 1
  fi

  complete-merge-current-branch-to-staging
}

function complete-merge-current-branch-to-staging() {
  git add .
  git commit -m "$(git log -1 --pretty=%B --oneline)"
  git merge

  branch=$(current_branch | sed -e 's/-STAGING-TMP$//g')

  git push origin "$branch-STAGING-TMP:staging"
  if [ $? -ne 0 ]; then
    echo "\033[0;31mPush failed\033[0m"
    return 1
  fi

  git checkout "$branch"
  if [ $? -ne 0 ]; then
    echo "\033[0;31mCheckout back failed\033[0m"
    return 1
  fi

  git branch -D "$branch-STAGING-TMP"
  if [ $? -ne 0 ]; then
    echo "\033[0;31mFailed to delete temporary branch\033[0m"
    return 1
  fi
}

alias gqm=merge-current-branch-to-staging
alias gqe=complete-merge-current-branch-to-staging

hijack:reset

hijack:transform '^(\w+)( .*)!$' \
  'sed -re "s/(\w+)( .*)\s*!$/\1!\2/"'

hijack:transform ' +$' \
  'sed -re "s/ +$//"'

hijack:transform '^g[gkx]?!? ' \
  'sed -r s"/([\\$<>{}&\\\"([!?)''#^ ])/\\\\\1/g"'

hijack:transform '^g[gkx]?\\!' \
  'sed -re "s/^(g[gkx]?)\\\\!/\\1!/"'

hijack:transform '^g[gkx]?!?\\ ' \
  'sed -r s"/^(g[gkx]?)(!?)\\\ /\\1\\2 /g"'

