BACKGROUND=dark

autoload -U add-zsh-hook
source ~/.bin/_zsh-hijack

export LC_ALL="en_US.UTF-8"
export TERM='xterm-256color'
export COLORTERM='rxvt-unicode-256color'

export PROMPT="%{$bg[blue]%}%{$fg[white]%}%2~ $%{$reset_color%} "
export QUOTA=20

HISTSIZE=999999999
SAVEHIST=999999999

APPEND_HISTORY=yes
INC_APPEND_HISTORY=yes
SHARE_HISTORY=yes

HIST_IGNORE_DUPS=no
HIST_IGNORE_ALL_DUPS=no
HIST_EXPIRE_DUPS_FIRST=no
HIST_SAVE_NO_DUPS=no
HIST_FIND_NO_DUPS=no

autoload -U select-word-style
select-word-style bash

bindkey "\e\e[D" backward-word
bindkey "\e\e[C" forward-word

bindkey "^[OA" hijack:history-substring-search-up
bindkey "^[[A" hijack:history-substring-search-up

autoload -U promptinit
promptinit

zle -N prepend-sudo prepend_sudo
function prepend_sudo() {
        if [ "$BUFFER" ]; then
                BUFFER="sudo "$BUFFER
        else
                BUFFER="sudo "$(fc -ln -1)
        fi
        CURSOR=$(($CURSOR+5))
}

function R() {
  nohup xdg-open "$@" > /dev/null 2> /dev/null &
  disown
}

# fzf-history-widget
bindkey '^R' fzf-history-widget
eval "$(sed -r -e 's/\+s//' -e '/bindkey/d' /usr/share/fzf/key-bindings.zsh)"

# fzf.vim passes --color argument overriding any custom colorscheme
args=()
while [[ "$1" ]]; do
    case "$1" in
        --color) shift 2;;
        *)       args+=("$1"); shift;;
    esac
done

bindkey "^U" prepend-sudo

# global
alias -g G="| grep"
alias -g X='| xsel -ib'

# utils
alias re='source ~/.bin/ushell-env && rehash' # reload env
alias f='find . -name'
alias ee='() { vim ~/.bin/ushell-env; source ~/.bin/ushell-env; rehash }'
alias cw='cd ~/src/constructor/website'
alias yay='yay --removemake --nodiffmenu --nocleanmenu --noupgrademenu --cleanafter'
alias mv=/bin/mv
alias pwgen='pwgen 12'
alias h='ssh'
alias w='inotifyrun -r -e MODIFY' # watch
alias ob='() { watch -x zsh -i -c "$@" }' # observe
alias l='exa -lHg --group-directories-first'
alias ls='exa -lHga'
alias rr='sudo rm -rf'
alias rt='sudo rm -rf ~/.tmp/ssh/*'
alias ks="kill \$(ps -xa | grep 'spring server' | grep -v 'grep' | awk '{print \$2}')"
alias kp="kill -9 \$(ps -xa | grep 'puma' | grep -v 'grep' | awk '{print \$2}')"
alias kk='() { kill -9 $(ps -xa | grep "$@" | grep -v "grep" | awk "{print \$2}") }' # observe
alias grep='grep --exclude-dir=.cvs --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --color=auto'
alias tree='tree --dirsfirst'
alias ps='ps -xau'
alias cal='cal -m $(date +%Y)'
alias co='sudo chown -R leo: '
alias cc='sudo chown -R leo: .'

# overmind
alias o='overmind'
alias oc='overmind connect'
alias oe='overmind restart'
alias oa='[ -e ./.overmind.sock ] && rm ./.overmind.sock; overmind start -F /dev/null --procfile .dev/Procfile -D -p 3000'
alias oaa='overmind start'
alias oo='overmind stop'

# secrets
alias pa='cd ~/.secrets; carcosa -Ac'
alias pg='cd ~/.secrets; carcosa -Gc'
alias pr='cd ~/.secrets; carcosa -Rc'

# code
alias e='code'
alias en='code -n'

# bundle
alias b='bundle exec'
alias bs='bundle exec ./bin/spring'
alias bi='bundle install'
alias bii='bundle install --path vendor/bundle --jobs 32'
alias bu='bundle update'

# npm
alias ni='npm install'
alias nl='npm install && git checkout package-lock.json'
alias el='touch ~"/projects/personal/log/$(date +%F_%H:%M).md"; code ~"/projects/personal/log/$(date +%F_%H:%M).md"'

# pacman
alias pm='sudo pacman'
alias pmi='sudo pacman --noconfirm -S'
alias pmr='sudo pacman -R'
alias pmro='sudo pacman -Rns $(pacman -Qtdq)'
alias pmq='pacman -Ql'
alias pf='pkgfile'

# systemctl
alias s='sudo systemctl'
alias sa='sudo systemctl start'
alias se='sudo systemctl restart'
alias so='sudo systemctl stop'
alias ss='sudo systemctl status'

# dotfiles
alias dfp='balmora dotfiles-submit'
alias dfu='balmora dotfiles-update'

export GREP_OPTIONS=''
export NODE_PATH="~/.node:/usr/lib/node_modules"
export WINEARCH='win32'

# nmcli
alias wr='nmcli -p dev wifi rescan'
alias wd='nmcli -p dev wifi list'
alias wc='nmcli -p dev wifi connect'
alias wl='nmcli -p con show'
alias ws='nmcli -p con show --active'
alias wu='nmcli -p con up id'

# go
alias gr=gorun
alias gg=go get

# docker
alias d='docker'
alias dx='docker exec -i -t'
alias di='docker inspect'
alias dp='docker ps --format "table{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}"'
alias dr='docker run --rm -i -t'
alias drm='docker rm --force'
alias dra='docker rm $(docker ps -q -a)'
alias da='docker start'
alias ds='docker stop'
alias dsa='docker stop $(docker ps -q)'
alias de='docker restart'
alias dl='docker logs --tail 200'
alias dlf='docker logs --follow'
alias da='docker attach --no-stdin'

# constructor

alias oj="overmind connect jest"
alias ot="overmind connect tsc"

# git
alias gg='() { grep $1 -R . }'
alias gs='git show --color'
alias gsf='git show --color --name-only'
alias gsp='git commit -v -a && git push'
alias gsa='git commit -v -a --amend && git push --force'
alias gsn='git commit -v -a --amend --no-verify && git push --force'
alias gcn='git commit --no-verify'
alias gpf='git push --force'
alias ge='git rebase'
alias gei='git rebase --interactive'
alias gec='git rebase --continue'
alias gea='git rebase --abort'
alias gpu='git push -u origin $(current_branch)'
alias gpuf='git push -u origin $(current_branch) --force'
alias gdc='git diff --cached'
alias gh='git stash'
alias ghp='git stash pop'
alias ghs='git stash -- $(git diff --staged --name-only)'
alias gfp='git fetch --prune'
alias gcm='git checkout master'
alias gt='git reset'
alias gth='git reset --hard'
alias glr='git pull --rebase'
alias gau='git update-index --assume-unchanged'
alias gac='git update-index --no-assume-unchanged'
alias gmm='git fetch && git merge origin/master'
alias gj='echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib' # copy last commit hash
alias gcoo='git checkout origin/master -- '
alias gdm='git diff $(git merge-base origin/master $(git rev-parse --abbrev-ref HEAD))'
alias gdl='git diff --name-only $(git merge-base origin/master $(git rev-parse --abbrev-ref HEAD)) | cat'
alias gbc='current_branch'

alias gbn='() {
  git fetch && \
    git checkout origin/master && \
    git checkout -b "$1"
}'

alias gz='() {
  git add . &&
    git commit -m "$(git-commit-prefix)$1" &&
    echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib
}'

alias gzn='() {
  git add . &&
  git commit -m "$(git-commit-prefix)$1" --no-verify &&
  echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib
}'

alias gzz='() {
  git add . &&
  git commit -m "$(git-commit-prefix)$1" --amend &&
  echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib
}'

alias gk='() { git commit -m "$(git-commit-prefix)$1" }'
alias gkn='() { git commit -m "$(git-commit-prefix)$1" --no-verify }'
alias gkk='() { git commit --amend }'

function git-commit-prefix() {
  branch=$(git rev-parse --abbrev-ref HEAD)
  message="$(echo -n $branch | grep -Eo 'ch([0-9]+)')"

  if [ ! -z "$message" ]; then
    echo -n "[$message] "
  else
    echo -n "[$branch] " 
  fi
}

alias gx='() {
  git add . && \
    git commit -m "$(git-commit-prefix)$1" && \
    git push -u origin $(current_branch) &&
    echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib
}'

alias gxn='() {
  git add . && \
    git commit -m "$(git-commit-prefix)$1" --no-verify && \
    git push -u origin $(current_branch) &&
    echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib
}'

alias gxx='() {
  git add .
  git commit -m "$(git log -1 --pretty=%s)" --amend
  git push -u origin $(current_branch) --force &&
  echo -n "$(git rev-parse HEAD | tr -d '\n')" | xsel -ib
}'

function rebase-current-branch-on-master() {
  git fetch
  git rebase origin/master
}

alias geo=rebase-current-branch-on-master

function create-pull-request() {
  repo=$(
    git remote -v |
      grep push |
      sed -r "s/.*@(.*):(.*)\.git\s.*/http:\/\/\1\/\2/g"
  )

  chromium "$repo/compare/$(current_branch)?expand=1"
}

alias gq=create-pull-request

alias gqm=merge-current-branch-to-staging
alias gqe=complete-merge-current-branch-to-staging

# kubernetes

alias k=':kubectl'
alias ka='k apply'
alias kaf='k apply -f'
alias kl='k logs'
alias klf='k logs -f'
alias kd='k describe'
alias kdp='k describe pods'
alias kds='k describe services'
alias kdd='k describe deployment'
alias kc='k create'
alias kcf='k create -f'
alias kr='k delete'
alias krf='k delete -f'
alias krp='k delete pod'
alias krs='k delete service'
alias krd='k delete deployment'
alias kg='k get'
alias kgp='k get pods'
alias kga='k get pods --all-namespaces -o wide'
alias kgs='k get services'
alias kgd='k get deployments'
alias kx='() { k exec -it $1 -- "${@:2}"}'
alias kxb='() { k exec -it $1 bash }'
alias kxc='() { k exec -it $1 rails c }'
alias kxx='k run -i --tty busybox --image=busybox --restart=Never -- sh'
alias kei='k exec'
alias kgn='kubectl config current-context'
alias ksc='kubectl config use-context '

alias ksn=' \
  kubectl config set-context $(kubectl config current-context) --namespace \
'

alias ksp='() {
  project=$(kubectl config get-contexts | grep -Po "(?<=@)$1\w*(?=\s)" | head -n 1)
  namespace=$(kubectl config current-context | grep -Po "\w+(?=@)")
  if [ ! "$namespace" ]; then
    namespace=$project
  fi

  kubectl config use-context $namespace@$project
}'

alias kxd='
  open-kubernetes-database-console \
    $(production-pod postgres)
'

:kubectl() {
    local arg
    local context
    local args=()
    local entity

    for arg in "$@"; do
        if [[ "$arg" =~ @.* ]]; then
            context=$(
                kubectl config get-contexts --no-headers -o name \
                    | grep -P "^${arg:1}"
            )
        else
            args+=("$arg")
        fi
    done

    set -- "${args[@]}"

    args=()
    targets=()

    if [[ ! "$context" ]]; then
        context=$(kubectl config current-context)
    fi

    for arg in "$@"; do
        if [[ "$arg" =~ %.* ]]; then
            entity=${arg%/*}

            if [[ "$entity" == "$arg" ]]; then
                entity=pod
            fi

            args+=($(
                kubectl --context=$context get "$entity" --no-headers \
                        -o name \
                    | cut -f2- -d/ \
                    | grep -P "^${${arg:1}#*/}" \
                    | head -n 1
            ))
        else
            args+=("$arg")
        fi
    done


    kubectl --context=$context ${(q)args[@]}
}

function open-kubernetes-database-console() {
  export DB=$(
    kubectl exec \
      $1 \
      -- \
      psql -P pager -Upostgres -c '\l' | \
      grep -E '^ ' | \
      grep -Ev '^ (postgres|template|ubuntu| )' | \
      grep -Eo '^ \w+' |
      grep -Eo '\w+'
  )

  kubectl \
    exec \
    -it \
    $1 \
    -- \
    psql -P pager -Uuser \
    $DB
}

# docker compose
alias dc='docker-compose'
alias c='docker-compose -f $(docker-compose-file)'
alias cu='docker-compose -f $(docker-compose-file) up'
alias cl='docker-compose -f $(docker-compose-file) logs'
alias cx='docker-compose -f $(docker-compose-file) exec'
alias cs='docker-compose -f $(docker-compose-file) stop'
alias css='docker-compose -f $(docker-compose-file) ps'

alias cr='\
  docker-compose -f $(docker-compose-file) stop
  docker-compose -f $(docker-compose-file) up
'

alias crm='\
  docker-compose -f $(docker-compose-file) stop;
  docker-compose -f $(docker-compose-file) rm -f
'

alias crr='\
  docker-compose -f $(docker-compose-file) stop
  docker-compose -f $(docker-compose-file) rm -f
  docker-compose -f $(docker-compose-file) up \
'

function docker-compose-file() {
  if [ -e config/*local/docker-compose.yml ]; then
    echo -n config/*local/docker-compose.yml
  fi

  if [ -e ./docker-compose.yml ]; then
    echo -n ./docker-compose.yml
  fi
}

# docker
alias dbe='docker exec -i -t $(application-container)'
alias dbea='docker exec -i -t $(docker-container "(backend|app|rails)\." admin)'
alias dte='docker exec -i -t $(docker-container "test.(backend|app|rails)" backend)'
alias dfe='docker exec -i -t $(docker-container frontend -v admin)'
alias dfea='docker exec -i -t $(docker-container frontend admin)'

alias x='docker exec -i -t $(application-container)'
alias xx='docker exec -i -t $(application-container)'
alias xb='docker exec -i -t $(application-container) bash'
alias xc='docker exec -i -t $(application-container) rails console'
alias xr='docker exec -i -t $(application-container) rails runner'
alias xdm='docker exec -i -t $(application-container) rake db:migrate'
alias xdr='docker exec -i -t $(application-container) rake db:rollback'
alias xdd='docker exec -i -t $(application-container) rake db:migrate:redo'
alias xdt='docker exec -i -t $(application-container) rake db:migrate:status'
alias xds='docker exec -i -t $(application-container) rake db:seed'

function application-container() {
  echo $(docker-container "(backend|app|rails|\swebsite)\." -v admin)
}

function docker-container() {
  echo $(
    docker ps --format "table{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}" |
    grep -E $1 |
    grep $2 $3 |
    sort -k 2 |
    head -n 1 |
    awk "{ print \$1 }"
  )
}

# hijacks

hijack:reset

hijack:transform '^(\w+)( .*)!$' \
  'sed -re "s/(\w+)( .*)\s*!$/\1!\2/"'

hijack:transform ' +$' \
  'sed -re "s/ +$//"'

hijack:transform '^g[zxk]?[n]?!? ' \
  'sed -r s"/([\\$<>{}&\\\"([!?)''#^ ])/\\\\\1/g"'

hijack:transform '^g[zxk]?[n]?\\!' \
  'sed -re "s/^(g[zxk]?[n]?)\\\\!/\\1!/"'

hijack:transform '^g[zxk]?[n]?!?\\ ' \
  'sed -r s"/^(g[zxk]?[n]?)(!?)\\\ /\\1\\2 /g"'

QUOTA=50

eval $(dircolors ~/.dircolors.$BACKGROUND)

if [[ ! "$TMUX" ]]; then
#  exec tmux new
fi

