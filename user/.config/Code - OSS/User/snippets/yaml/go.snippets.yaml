typescript:
  context: document().languageId.match("^go$")
  snippets:
    type:
      trigger: ~^t$
      order: 1
      snippet: type $1

    type struct:
      trigger: ~(?<=type\s+\w+\s+)s$
      auto: true
      snippet: |-
        struct {
          $0
        }

    type interface:
      trigger: ~(?<=type\s+\w+\s+)i$
      auto: true
      snippet: |-
        interface {
          $0
        }

    struct:
      trigger: ~^s$
      order: 1
      snippet: |-
        type $1 struct {
          $0
        }

    func:
      trigger: fn
      snippet: |-
        func $1:name($2) $3 {
          $0
        }

    for:
      trigger: ~(?<=^\s*)f$
      order: 1
      snippet: |-
        for $1 {
          $0
        }

    for classic:
      trigger: ~(?<=^\s*)fo$
      order: 1
      snippet: |-
        for $1:name{index} := $2{0}; $1:name{index} < $3; $1:name{index} ++ {
          $0
        }

    for index:
      trigger: ~(?<=^\s*)fi$
      snippet: |-
        for $1{index}, $3:value{value} := range $2:values{values} {
          $0
        }
      placeholders:
        value:
          onBeforeFocus: |
            ({ placeholders: { values }, extensions: { user } }) => {
              return user.pluralize.singular(values.value) || values.value;
            }

    for index helper:
      trigger: ~for i$
      snippet: |-
        for $1{index}, $3:value{value} := range $2:values{values}
      placeholders:
        value:
          onBeforeFocus: |
            ({ placeholders: { values }, extensions: { user } }) => {
              return user.pluralize.singular(values.value) || values.value;
            }
      order: 3

    for range:
      trigger: ~(?<=^\s*)fr$
      snippet: |-
        for _, $2:value{value} := range $1:values{values} {
          $0
        }
      placeholders:
        value:
          onBeforeFocus: |
            ({ placeholders: { values }, extensions: { user } }) => {
              return user.pluralize.singular(values.value);
            }

    break:
      trigger: b
      snippet: break

    continue:
      trigger: c
      snippet: continue

    "nil":
      trigger: n
      snippet: "nil"

    "false":
      trigger: f
      snippet: "false"

    "true":
      trigger: t
      snippet: "true"

    float64:
      trigger: ff
      snippet: float64

    float64 continuation:
      trigger: "false"
      snippet: float64

    float64 type:
      trigger: ~(?<=(\w\s|\))\s*)(?<!return\s+)f$
      snippet: float64
      order: 1

    int type:
      trigger: ~(?<=\S.*\s+)i$
      snippet: int
      order: 1

    bool type:
      trigger: ~(?<=\S.*\s+)b$
      snippet: bool
      order: 1

    string:
      trigger: ~(?<=(\w\s|\)|\W)\s*)s$
      snippet: string

    error type:
      trigger: ~(?<=\S.*\s+)e$
      snippet: error
      order: 1

    return:
      trigger: r
      snippet: return $0

    return nil:
      trigger: rn
      snippet: return nil

    return false:
      trigger: rf
      snippet: return false

    return true:
      trigger: rt
      snippet: return true

    return result:
      trigger: rr
      snippet: return result

    define variable:
      trigger: ~;$
      auto: true
      snippet: ":= "

    semicolon:
      trigger: ~:=$
      snippet: ";"

    range:
      trigger: ~(?<=for\s+\w+(,\s+\w+)?\s*:?=)\s*$
      snippet: " range "

    equal range:
      trigger: ~(?<=for\s+\w+(,\s+\w+)?\s*)\s*$
      snippet: " := range "

    for underscore:
      trigger: ~(?<=for\s+)$
      snippet: "_, $1 := range "

    func struct:
      trigger: d
      snippet: |-
        // $2{name} TBD
        func ($struct{struct}) $2{name}($3) $4 {
          $0
        }
      placeholders:
        struct:
          onBeforeExpand: |
            ({ document, cursor, extensions: { user } }) => {
              const expr = /(?<=func \()(.*?)(?=\) \w+\()/;

              const backwardDefinition = user.getText(document, expr, {
                before: cursor.anchor,
              });

              if (backwardDefinition) {
                return backwardDefinition;
              }

              const globalDefinition = user.getText(document, expr);

              if (globalDefinition) {
                return globalDefinition;
              }

              const name = user.getText(
                document,
                /(?<=type\s+)(\w+)(?=\s+struct)/,
                { before: cursor.anchor },
              );

              if (name) {
                return `${user.camelcase(name)} *${name}`;
              }

              return ;
            }

    if err not nil return err:
      trigger: ie
      snippet: |-
        if err != nil {
          return $1err
        }

    if err not nil panic:
      trigger: ip
      snippet: |-
        if err != nil {
          panic(err)
        }

    if:
      trigger: i
      snippet: |-
        if $1 {
          $0
        }

    if not:
      trigger: in
      snippet: |-
        if !$1 {
          $0
        }

    else:
      auto: true
      trigger: ~(?<=}\s*)e$
      snippet: |-
        else {
          $0
        }

    else if:
      auto: true
      trigger: ~(?<=}\s*)i$
      snippet: |-
        else if $1 {
          $0
        }

    log:
      trigger: l
      snippet: fmt.Println("XXXX $id ", $1)
      placeholders:
        id:
          onBeforeExpand: |
            ({ cursor, document }) =>
              require('path').basename(document.uri.fsPath) + ':' +
              cursor.anchor.line

    len:
      trigger: ~(?<=\S.*)l$
      snippet: len($1)
      order: 1

    log structure:
      trigger: lv
      snippet: fmt.Printf("XXXX $id %+v\n", $1)
      placeholders:
        id:
          onBeforeExpand: |
            ({ cursor, document }) =>
              require('path').basename(document.uri.fsPath) + ':' +
              cursor.anchor.line

    assert equal values:
      trigger: ae
      snippet: assert.EqualValues(test, $1{expected}, $2{actual})

    errors new:
      trigger: en
      snippet: errors.New("$1")

    # language

    append:
      trigger: ~(?<==\s*)a$
      snippet: append($1:list, $2:value)
      placeholders:
        list:
          onBeforeExpand: |-
            ({ document, cursor, extensions: { user } }) =>
              user.getText(
                document,
                /\S+(?=\s*=\s*a$)/,
                { before: cursor.anchor },
              );

    map:
      trigger: m
      snippet: map[$1:key]$2:value

    make:
      context: cursor.precedingText().match('=\s*m$')
      trigger: m
      snippet: make([]$1{type}, $2{len})
      order: 1

    exit:
      trigger: q
      snippet: panic(":(")

    panic:
      trigger: p
      snippet: panic("$1")

    package:
      trigger: ~^p$
      snippet: |
        package $package
      order: 1

      placeholders:
        package:
          onBeforeExpand: |-
            ({ document }) =>
              document.uri.fsPath.match(/\/([^/]*?)\/[^/]*$/)[1]

    karma describe:
      trigger: kd
      snippet: karma.Describe("$1", $2)

    karma describe continuation:
      context: cursor.precedingText().match('\.\s*d$')
      trigger: d
      snippet: Describe("$1", $2)
      order: 1

    karma reason:
      context: cursor.precedingText().match('\.\s*r$')
      trigger: r
      snippet: Reason("$1")
      order: 1

    comment:
      trigger: c
      context: |
        cursor.followingText().match('^\s*(func|type)')
      snippet: // $name{name} $1{TBD}
      order: 1
      placeholders:
        name:
          onBeforeExpand: |
            ({ document, cursor, extensions: { user } }) => {
              const definition = user.getText(
                document,
                /((?<=func ((.*?) )?)\w+(?=\()|(?<=type )\w+)/,
                { after: cursor.anchor },
              );

              if (definition) {
                return definition;
              }

              const globalDefinition = user.getText(document, expr);

              if (globalDefinition) {
                return globalDefinition;
              }

              const name = user.getText(
                document,
                /(?<=type\s+)(\w+)(?=\s+struct)/,
                { before: cursor.anchor },
              );

              if (name) {
                return `${user.camelcase(name)} *${name}`;
              }

              return ;
            }
