go:
  context: document().languageId.match("^go$")
  snippets:
    type:
      trigger: ~^t$
      order: 1
      snippet: type $1

    type struct:
      trigger: ~(?<=type\s+\w+\s+)s$
      auto: true
      snippet: |-
        struct {
          $0
        }

    type interface:
      trigger: ~(?<=type\s+\w+\s+)i$
      auto: true
      snippet: |-
        interface {
          $0
        }

    func:
      trigger: fn
      snippet: |-
        func $1:name($2) $3 {
          $0
        }

    for:
      context: cursor.followingText().match('^\s*\n')
      trigger: ~(?<=^\s*)f$
      order: 1
      snippet: |-
        for $1 {
          $0
        }

    for classic:
      trigger: ~(?<=^\s*)fo$
      order: 1
      snippet: |-
        for $1:name{index} := $2{0}; $1:name{index} < $3; $1:name{index} ++ {
          $0
        }

    for copy:
      trigger: ~(?<=^\s*)fc$
      snippet: |-
        $1 := make([]$2, len($3))
        for $4{index}, $5{value} := range $3 {
          $1[$4{index}] = $5{value}$6
        }

    for keys:
      trigger: ~(?<=^\s*)fk$
      snippet: |-
        $1 := make([]$2, len($3))
        $4{index} := 0
        for $5{key} := range $3 {
          $1[$4{index}] = $5{key}
          $4{index} ++
        }

    for index:
      trigger: ~(?<=^\s*)fi$
      snippet: |-
        for $1{index}, $3:value{value} := range $2:values{values} {
          $0
        }
      placeholders:
        value:
          onBeforeFocus: |
            ({ placeholders: { values }, extensions: { user } }) => {
              return user.pluralize.singular(values.value) || values.value;
            }

    for index helper:
      trigger: ~for i$
      snippet: |-
        for $1{index}, $3:value{value} := range $2:values{values}
      placeholders:
        value:
          onBeforeFocus: |
            ({ placeholders: { values }, extensions: { user } }) => {
              return user.pluralize.singular(values.value) || values.value;
            }
      order: 3

    for range:
      trigger: ~(?<=^\s*)fr$
      snippet: |-
        for _, $2:value{value} := range $1:values{values} {
          $0
        }
      placeholders:
        value:
          onBeforeFocus: |
            ({ placeholders: { values }, extensions: { user } }) => {
              return user.pluralize.singular(values.value);
            }

    break:
      trigger: b
      snippet: break

    continue:
      trigger: c
      snippet: continue

    "nil":
      trigger: n
      snippet: "nil"

    "false":
      trigger: f
      snippet: "false"

    "true":
      trigger: t
      snippet: "true"

    float64 continuation:
      trigger: "false"
      snippet: float64

    float64 type:
      trigger: ~(?<=(\w\s|\))\s*)(?<!return\s+)f$
      snippet: float64
      order: 1

    types:
      context: cursor.precedingText().match('(\S.*[ ]*|\(|\[|\]|\))\w+$')
      snippets:
        int type:
          trigger: i
          snippet: int
          order: 1

        bool type:
          trigger: b
          snippet: bool
          order: 1

        string:
          trigger: s
          snippet: string

        error type:
          trigger: e
          snippet: error
          order: 1

        float64:
          trigger: ff
          snippet: float64

    return:
      trigger: r
      snippet: return $0

    return nil:
      trigger: rn
      snippet: return nil

    return false:
      trigger: rf
      snippet: return false

    return true:
      trigger: rt
      snippet: return true

    return result:
      trigger: rr
      snippet: return result

    define variable:
      trigger: ~;$
      auto: true
      snippet: ":= "

    var:
      trigger: v
      snippet: "var "

    var error continuation:
      trigger: ~var\s+$
      snippet: var err error

    var error:
      trigger: ve
      snippet: var err error

    semicolon:
      trigger: ~:=$
      snippet: ";"

    range:
      trigger: ~(?<=for\s+\w+(,\s+\w+)?\s*:?=)\s*$
      snippet: " range "

    equal range:
      trigger: ~(?<=for\s+\w+(,\s+\w+)?\s*)\s*$
      snippet: " := range "

    for underscore:
      trigger: ~(?<=for\s+)$
      snippet: "_, $1 := range "

    struct:
      trigger: ~^ds$
      snippet: |-
        // $1:name TBD
        type $1:name struct {
          $0
        }
      placeholders:
        name:
          onBeforeExpand: |-
            ({ document }) => {
              const fileName = document.uri.fsPath.match(/\/([^/\.]*)[^/]*$/)[1];
              return fileName[0].toLocaleUpperCase() + fileName.substring(1)
            }

    interface:
      trigger: ~^di$
      snippet: |-
        // $1:name TBD
        type $1:name interface {
          $0
        }
      placeholders:
        name:
          onBeforeExpand: |-
            ({ document }) => {
              const fileName = document.uri.fsPath.match(/\/([^/\.]*)[^/]*$/)[1];
              return fileName[0].toLocaleUpperCase() + fileName.substring(1)
            }

    define package:
      context: cursor.bofToStartText().match('^\s*\w+$')
      trigger: d
      snippet: "package $package\n\n"
      order: 2
      placeholders:
        package:
          onBeforeExpand: |-
            ({ document }) =>
              document.uri.fsPath.match(/\/([^/]*?)\/[^/]*$/)[1]

    define package main:
      context: cursor.bofToStartText().match('^\s*\w+$')
      trigger: dm
      snippet: "package main\n\n"

    define struct:
      context: |
        !cursor.bofToStartText().match('\n\s*type ')
      trigger: d
      snippet: |
        // $1 TBD
        type $1 struct {
          $0
        }

    define func struct:
      context: cursor.bofToStartText().match('\n\s*type ')
      trigger: d
      snippet: |-
        // $2{name} TBD
        func ($struct{struct}) $2{name}($3) $4 {
          $0
        }
      placeholders:
        struct:
          onBeforeExpand: |
            ({ document, cursor, extensions: { user } }) => {
              const expr = /(?<=func \()(.*?)(?=\) \w+\()/;

              const backwardDefinition = user.getText(document, expr, {
                before: cursor.anchor,
              });

              if (backwardDefinition) {
                return backwardDefinition;
              }

              const globalDefinition = user.getText(document, expr);

              if (globalDefinition) {
                return globalDefinition;
              }

              const name = user.getText(
                document,
                /(?<=type\s+)(\w+)(?=\s+struct)/,
                { before: cursor.anchor },
              );

              if (name) {
                return `${user.camelcase(name)} *${name}`;
              }

              return ;
            }

    define test:
      context: document().uri.toString().match("_test.go$")
      trigger: d
      snippet: |
        func Test$1(test *testing.T) {
          $0
        }
      order: 1

    if err not nil return err:
      trigger: ie
      snippet: |-
        if err != nil {
          return $1err
        }

    if err not nil panic:
      trigger: ip
      snippet: |-
        if err != nil {
          panic(err)
        }

    if:
      trigger: i
      snippet: |-
        if $1 {
          $0
        }

    if not:
      trigger: in
      snippet: |-
        if !$1 {
          $0
        }

    else:
      auto: true
      trigger: ~(?<=}\s*)e$
      snippet: |-
        else {
          $0
        }

    else if:
      auto: true
      trigger: ~(?<=}\s*)i$
      snippet: |-
        else if $1 {
          $0
        }

    log:
      trigger: l
      snippet: fmt.Println("XXXX $id ", $1)
      placeholders:
        id:
          onBeforeExpand: |
            ({ cursor, document }) =>
              require('path').basename(document.uri.fsPath) + ':' +
                cursor.anchor.line

    log fatal:
      trigger: lf
      snippet: log.Fatal($1)

    len:
      trigger: ~(?<=\S.*)l$
      snippet: len($1)
      order: 1

    log structure:
      trigger: lv
      snippet: fmt.Printf("XXXX $id %+v\n", $1)
      placeholders:
        id:
          onBeforeExpand: |
            ({ cursor, document }) =>
              require('path').basename(document.uri.fsPath) + ':' +
              cursor.anchor.line

    assert equal values:
      trigger: ae
      snippet: assert.EqualValues(test, $1{expected}, $2{actual})

    errors new:
      trigger: en
      snippet: errors.New("$1")

    # language

    append:
      trigger: ~(?<==\s*)a$
      snippet: append($1:list, $2:value)
      placeholders:
        list:
          onBeforeExpand: |-
            ({ document, cursor, extensions: { user } }) =>
              user.getText(
                document,
                /\S+(?=\s*=\s*a$)/,
                { before: cursor.anchor },
              );

    map:
      trigger: m
      snippet: map[$1:key]$2:value

    map value:
      context: cursor.precedingText().match('(=|\()\s*m$')
      trigger: m
      snippet: map[$1:key]$2:value\{\}
      order: 1

    make:
      trigger: ma
      snippet: make([]$1{type}, $2{len})
      order: 1

    slice:
      trigger: ss
      auto: true
      snippet: "[]"

    exit:
      trigger: q
      snippet: panic(":(")

    panic:
      trigger: p
      snippet: panic("$1")

    package:
      trigger: ~^p$
      snippet: |
        package $package
      order: 1
      placeholders:
        package:
          onBeforeExpand: |-
            ({ document }) =>
              document.uri.fsPath.match(/\/([^/]*?)\/[^/]*$/)[1]

    karma error:
      trigger: ke
      snippet: karma.$2Format("$1", "error", err)

    karma describe:
      trigger: kd
      snippet: karma.Describe("$1{value}", $2{$1{value}}).Reason($3)

    karma describe continuation:
      context: cursor.precedingText().match('\.\s*d$')
      trigger: d
      snippet: Describe("$1{value}", $2{$1{value}}).
      order: 1

    karma reason:
      context: cursor.precedingText().match('\.\s*r$')
      trigger: r
      snippet: Reason("$1")
      order: 1

    comment:
      trigger: c
      context: |
        cursor.followingText().match('^\s*(func|type)')
      snippet: // $name{name} $1{TBD}
      order: 1
      placeholders:
        name:
          onBeforeExpand: |
            ({ document, cursor, extensions: { user } }) => {
              const definition = user.getText(
                document,
                /((?<=func ((.*?) )?)\w+(?=\()|(?<=type )\w+)/,
                { after: cursor.anchor },
              );

              if (definition) {
                return definition;
              }

              const globalDefinition = user.getText(document, expr);

              if (globalDefinition) {
                return globalDefinition;
              }

              const name = user.getText(
                document,
                /(?<=type\s+)(\w+)(?=\s+struct)/,
                { before: cursor.anchor },
              );

              if (name) {
                return `${user.camelcase(name)} *${name}`;
              }

              return ;
            }

    time date:
      trigger: td
      snippet: time.Date(2000$1, $2{1}, $3{1}, 0, 0, 0, 0, time.UTC)

    time time:
      trigger: tt
      snippet: time.Time
